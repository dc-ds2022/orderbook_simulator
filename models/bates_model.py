import numpy as np


def max_func(x):
    return max(0, x)


"""
Implementation of the Bates model of stochastic volatility with jumps for simulating returns.
This implementation assumes a Poisson distribution of jump events with the jump magnitude determined from a
normal distribution centered around the jump mean (this can be zero or above/below zero). 
For more information on the Bates model, see https://en.wikipedia.org/wiki/Stochastic_volatility_jump.
"""


class BatesModel:
    """
    :param starting_price (float): the current stock price
    :param drift_rate (float): the non-random drift rate of the process
    :param spot_vol_variance_correlation (float): Rho in the Bates model, the correlation of the random processes between
    the stock price and underlying volatility process (this is usually negative for equities)
    :param mean_reversion_of_vol_speed (float): Kappa in the Bates model, this is how "fast" volatility should revert back to its
    historical average (theta, the long variance)
    :param long_variance (float): Theta in the Bates model, the long term average of volatility
    :param volatility_of_volatility (float): Psi in the Bates model, how much the volatility process should vary
    :param mean_jump_size (float) - the mean of the jump magnitude distribution (center of normal distribution)
    :param jump_size_variance (float) - the variance of the jump magnitude distribution
    :param rate_of_jumps (float) - lambda_d in the Bates Model, the Poisson rate of jump events
    """

    def __init__(self, starting_price, drift_rate, spot_vol_variance_correlation, mean_reversion_of_vol_speed,
                 long_variance, volatility_of_volatility, mean_jump_size, jump_size_variance, rate_of_jumps):
        self.starting_price = starting_price
        self.drift_rate = drift_rate
        self.spot_vol_variance_correlation = spot_vol_variance_correlation
        self.mean_reversion_of_vol_speed = mean_reversion_of_vol_speed
        self.long_variance = long_variance
        self.volatility_of_volatility = volatility_of_volatility
        self.mean_jump_size = mean_jump_size
        self.jump_size_variance = jump_size_variance
        self.rate_of_jumps = rate_of_jumps

    """
    Monte Carlo approach to option pricing. This simply looks at the average payoff implied on day delta_t
    for the underlying according to the valuation of the option at expiry (max(0, S_t - K)) and returns that
    as the appropriate option price.
    :param simulated_paths (np.matrix) - all returned paths from simulated_paths
    :param strike (float) - the strike price of the option we're trying to price
    :param delta_t (integer) - the tenor we're trying to price (from current)
    :returns (float) the option price
    """

    @staticmethod
    def mc_option_price(simulated_paths, strike, delta_t):
        # Retrieve the simulated values at day t (delta_t)
        sim_paths = simulated_paths[:, delta_t]
        # Calculate the payoffs at expiry according to max(0, S_t - K) where S_t is the simulated price
        # and K is the strike
        simulated_payoffs = np.array([sim - strike for sim in sim_paths])
        # Return the mean of all potential simulated payoffs; this should be the price of our option
        return np.array(map(max_func, simulated_payoffs)).mean()

    """
    Simulates paths created by the provided parameters (a Monte Carlo approach).
    :param number_of_steps (integer) - Number of steps per simulation
    :param number_of_simulations (integer) - The number of columns of returned matrix (number of simulations)
    :param risk_neutral (boolean) - Whether to treat the current measure as risk neutral
    """

    def simulate_paths(self, number_of_steps=2000, number_of_simulations=100, risk_neutral=False):
        if 2 * self.mean_reversion_of_vol_speed * self.long_variance <= self.volatility_of_volatility ** 2:
            print("Feller condition not satisfied. Potential simulation of negative volatility values.")

        # Set our time increment (dt) equal to one step (1/number of steps)
        dt = 1 / number_of_steps
        # Create empty matrices to represent the paths and volatilities generated by the model
        # This should be equal in size to number of simultions x number of steps + 1
        simulated_paths = np.zeros([number_of_simulations, number_of_steps + 1])
        simulated_volas = np.zeros([number_of_simulations, number_of_steps + 1])
        # Set the first price in the path equal to our desired starting price
        simulated_paths[:, 0] = self.starting_price
        # Set the first step's volatility in the path equal to the long variance
        simulated_volas[:, 0] = self.long_variance

        # To properly simulate the Heston stochastic volatility process, we have to create
        # two volatility processes (each step should be independent and normally distributed)
        # one for the underlying stock price (Z_s) and another for the volatility (Z_v)
        # these should be correlated by our spot_vol_variance_correlation

        Z_V = np.random.normal(size=[number_of_simulations, number_of_steps + 1])
        Z_corr = np.random.normal(size=[number_of_simulations, number_of_steps + 1])
        Z_S = self.spot_vol_variance_correlation * Z_V + np.sqrt(1 - self.spot_vol_variance_correlation ** 2) * Z_corr

        # Similarly, for all steps in the path except the first, we should determine if a jump occurs or not
        # This is Poisson-distributed with rate lambda_d (rate of jumps), which at any given timestep
        # is equivalent to a Bernoulli random variable with probability = rate of jumps
        Bernoulli = np.random.binomial(n=1, p=self.rate_of_jumps * dt, size=[number_of_simulations, number_of_steps])

        # For each step we want to generate (regardless of number of simulations)
        for i in range(number_of_steps):
            # Fetch whether the jump has or has not occurred for that step (across all simulations)
            has_jump_occurred = Bernoulli[:, i].reshape(-1, 1)
            # If a jump has occurred (value = 1), we should use a normal distribution to determine the jump magnitude
            # per the calibrated mean and variance of the jump size (sqrt of it to get stdev)
            jump_magnitude = has_jump_occurred * np.random.normal(loc=self.mean_jump_size,
                                                                  scale=np.sqrt(self.jump_size_variance),
                                                                  size=has_jump_occurred.shape)

            # --- get the stochastic volatility component
            prior_step_vol = simulated_volas[:, i]
            simulated_volas[:, i + 1] = prior_step_vol + self.mean_reversion_of_vol_speed * (
                        self.long_variance - prior_step_vol) * dt + \
                                        self.volatility_of_volatility * np.sqrt(prior_step_vol) * np.sqrt(dt) * Z_V[:,
                                                                                                                i + 1] + (
                                                0.5 ** 2) * (self.volatility_of_volatility ** 2) * dt * (
                                                    Z_V[:, i + 1] ** 2 - 1)
            # Remove any negative volatility values (not possible), should not occur if Feller condition is satisfied
            simulated_volas[:, i + 1] = list(map(lambda x: max(0, x), simulated_volas[:, i + 1]))

            # --- get drift with compensator
            if risk_neutral:
                drift = (self.cost_of_carry - simulated_volas[:, i + 1] / 2 - self.rate_of_jumps *
                         (np.exp(self.mean_jump_size + simulated_volas[:, i + 1] / 2) - 1))
            else:
                drift = (self.drift_rate - simulated_volas[:, i + 1] / 2 - self.rate_of_jumps *
                         (np.exp(self.mean_jump_size + simulated_volas[:, i + 1] / 2) - 1))

            # --- get the total price dynamics
            simulated_paths[:, i + 1] = simulated_paths[:, i] * np.exp(
                drift * dt + np.sqrt(simulated_volas[:, i + 1] * dt) * Z_S[:, i + 1] + jump_magnitude.flatten())
        return simulated_paths, simulated_volas
